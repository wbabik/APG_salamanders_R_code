library(tidyverse)
library(ape)

# On 20.04.21 code run again on data with 13 Triturus individuals (14924-34, 14936-37) removed from the MIP dataset â€“ 
# these were Triturus individuals that were MIPped because their transcriptomes were sequenced.
# On 16.02.21 moved into the new project and all the code checked and executed on updated data
# On 5.01.21 small modifications included to produce segments from data with MIPs with median coverage < 20 excluded
# this modification didn't require re-running microhap - just some MIPs were filtered out from the microhap .rds output

# The script processes in the loop taxa provided in a vector
# - reads reference, MIP bed, and microhap .rds output
# - updates microhap .rds and adds full haplotype sequences
# - the main routine (seg_MIP function) does for each segment one of the following:
#   - if repr_MIP = TRUE picks for each segment a representative MIP based on coverage and the number of SNPs
# and maximizing coniguity, i.e., the MIP is retained as representative of subsequent segments 
# as long as it fulfill basic qual criteria; adjacent segments represented by the same MIP are then collapsed
# - if repr_MIP = FALSE then for each all segment all the MIP fragments covering it are reported and no collapsing is done
# - seg_MIP returns list with three elements: 1) "uncollapsed", 2) "collapsed", 3) "raw_MIP_seg".
# If repr_MIP = TRUE, the two firs contain dataframes and the 3rd NULL.
# If repr_MIP = FALS, the two first contain NULL and the 3rd is dataframe
# - after adding some additional data the final result of this script is dataframe with 20 or 21 variables
# containing for each individual and each segment its coordinates, haplotype (full seq) 
# and various coverage and polymorphism statistics
# 
# Requires the following inputs:
# - fasta reference *_APG_controls_references.fas
# - MIP coordinates *_MIP.bed
# - rds file with the dataframe produced by microhap *.rds (this one is produced by microhap_runner_Linux.R)
# - per MIP per individual coverage *_MIPcoverage_Ind.txt
# - segment coordinates and number of SNPs from a MIP, generated by bash script *_segments_on_MIPs_SNPs.bed
# (this one is used only within seg_MIP function and not passed as function argument)

options(scipen = 999)

seg_MIP <- function(sp, repr_MIP = FALSE, method = "black"){
  #processes information about segments, adds additional info and returns updated df
  #repr_MIP controls whether the procedure of picking up a representative MIP 
  #(the one with most SNPs and sufficient coverage) 
  #and collapsing adjacent segments represented by the same MIP is performed 
  #if FALSE all MIPs covering the segment are resported in the result
  get_MIPs_for_segments <- function(g, seg, gat, met="black"){
    #takes as arguments gene id, list of segments produced by the bash script and taxon
    #two variants: black prevents MIP to "re-appear" in as a representative of subsequent segemnt,
    #white(or any other string) does not
    #in real life the effect of this option would be minimal
    
    #gets the (nonredundant) list of segments sorted by seg_start
    d <- seg %>% filter(gene == g)
    sor_seg <- d %>% select(seg_start_ref, seg_id) %>% 
      arrange(seg_start_ref) %>% 
      unique() %>% pull(seg_id)
    #critera: nSNP, MIPcov, contnuity, optional black_list
    cur <- "0"
    counter <- 0
    black_list <- vector("double", length(sor_seg))
    MIP_seg  <-  vector("list", length(sor_seg))
    for(i in seq_along(sor_seg)){
      #ranks MIPs within segment: by # SNPs in segment (desc) and coverage threshold (desc)
      m <- d %>% filter(seg_id == sor_seg[[i]]) %>% 
        mutate(rank = dense_rank(interaction(desc(nSNP), desc(abov_thr), lex.order = T))) %>%
        filter(rank == 1) %>% arrange(MIP_id)
      #get MIP_ids of all MIPs in the 1st rank
      if (met == "black") {
        mip <- m %>% filter(!MIP_id %in% black_list) %>% pull(MIP_id)
      } else {
        mip <- m %>% pull(MIP_id)
      }
      #if current MIP in the 1st rank, keep it, otherwise pick the first (i.e. random),
      #which will also become new current,
      #add old current to black_list (will be used further or not)
      if (cur %in% mip) {
        r <- m %>% filter(MIP_id == cur)
      } else {
        counter <- counter + 1
        #not used if met is not "black"
        black_list[counter] <- cur
        r <- m[1,]
        cur <- r[1, "MIP_id"]
      }
      res <- r %>% mutate(species = gat) %>% 
        select(species, gene, seg_start_ref, seg_end_ref, seg_id, 
               seg_start_MIP, seg_end_MIP, MIP_id, nSNP, abov_thr)
      MIP_seg[[i]] <- res
    }
    #this contains the single MIP picked for each segment
    t <- bind_rows(MIP_seg)
    #then collapsing adjacent segments represented by the same MIp into one segment
    y <- NULL
    for(r in 1:nrow(t)){
      if(r == 1){
        cur_row <- t[1,]
        coll_st_ref <- cur_row[,"seg_start_ref"]
        coll_st_MIP <- cur_row[,"seg_start_MIP"]
        cur_nSNP <- cur_row[, "nSNP"]
        cur_seg <- cur_row[,"seg_id"]
        id <- cur_row[,"MIP_id"]
      } else {
        if(t[r, "MIP_id"] == id){
          cur_row <- t[r,]
          cur_seg <- paste(cur_seg, t[r, "seg_id"], sep = ";")
          cur_nSNP <- t[r, "nSNP"] + cur_nSNP
          if((r == nrow(t)) || (t[[r+1,2]] != t[[r,2]])){
            x <- cbind(cur_row[, c(1, 2, 4, 7, 8, 10)], coll_st_ref, coll_st_MIP, cur_seg, cur_nSNP)
            y <- rbind(y, x)
          }
        } else {
          x <- cbind(cur_row[, c(1, 2, 4, 7, 8, 10)], coll_st_ref, coll_st_MIP, cur_seg, cur_nSNP)
          cur_row <- t[r,]
          coll_st_ref <- cur_row[,"seg_start_ref"]
          coll_st_MIP <- cur_row[,"seg_start_MIP"]
          cur_nSNP <- cur_row[, "nSNP"]
          cur_seg <- cur_row[,"seg_id"]
          id <- cur_row[,"MIP_id"]
          if((r == nrow(t)) || (t[[r+1,2]] != t[[r,2]])){
            z <- cbind(cur_row[, c(1, 2, 4, 7, 8, 10)], coll_st_ref, coll_st_MIP, cur_seg, cur_nSNP)
            x <- rbind(x, z)
          }
          y <- rbind(y, x)
        }
      }
    }
    y <- y %>% select(c(1, 2, 7, 3, 5, 8, 4, 9, 10, 6))
    colnames(y) <- c("species", "gene", "coll_start_ref", "coll_end_ref", "MIP_id", 
                     "coll_start_MIP", "coll_end_MIP", "coll_seg_id", "coll_nSNP", "abov_thr")
    y <- y %>% mutate(coll_length = coll_end_MIP - coll_start_MIP)
    #return(y)
    z <- list(t,y)
    return(z)
  }  
  
  #reads bed with segment coordinates and number of SNPs from a MIP, generated by bash script
  seg <- read.table(paste0("beds/", sp, "_segments_on_MIPs_SNPs_min20cov.bed"), header = F, sep = "\t", encoding="UTF-8")
  colnames(seg) <- c("gene", "seg_start_ref", "seg_end_ref", "seg_id",
                     "MIP_start_ref", "MIP_end_ref", "MIP_id", "MIP_SNP", "nSNP")
  
  #filters out MIPs that don't overlap the segment
  seg <- seg %>% filter(MIP_id == MIP_SNP) %>% select(-MIP_SNP)
  
  #makes names of segments unique
  #inspired by a very rare case, in Prot_ang there were two segments with the same name
  #because it happened that two distinct segments overlapped only one, the same MIP
  seg <- seg  %>% group_by(gene, seg_id, MIP_id) %>% 
    mutate(suffix = row_number(),
           seg_id = paste0(seg_id, "_", suffix)) %>% 
    select(-suffix) %>% ungroup()
  
  
  #adds coordinates of a segment on MIP
  seg <- seg %>% mutate(seg_start_MIP = seg_start_ref - MIP_start_ref,
                        seg_end_MIP = seg_end_ref - MIP_start_ref) 
  
  #generates summary of coverage per MIP per individual
  #data for each species is in a separate text file
  cov_table <-  paste0("cov/", sp, "_MIPcoverage_Ind.txt")
  MIP_cov <- read.table(cov_table, header = T, sep = "\t", encoding="UTF-8")
  sp_cov <- MIP_cov %>% rename(MIP_id = MIP) %>% filter(Species==sp)
  if(repr_MIP == TRUE){
    #classifies MIPs as below or above coverage threshold
    cov_sum <- sp_cov %>% group_by(MIP_id) %>% 
      summarise(n=n(),
                cov_10plus = sum(Coverage > 10)/n) %>%
      mutate(abov_thr = ifelse(cov_10plus >=0.8, 1, 0))
    MIP_info <- cov_sum %>% select(MIP_id, abov_thr)
    
    #complete info to identify the path of MIPs
    segm <- left_join(seg, MIP_info, by = "MIP_id")
    genes <- segm %>% pull(gene) %>% unique() %>% sort()
    
    #pick representative MIP per segments
    #the function returns list containing both uncollapsed (original)
    #and collapsed (if for adjacent segments the same MIP was picked)
    seg_MIPs <- lapply(genes, get_MIPs_for_segments, seg=segm, gat=sp, met=method)
    
    #put uncollapsed and collapsed into dataframes,
    #saves them into text files and returns two element list
    uncollapsed <- vector("list", length(seg_MIPs))
    collapsed <- vector("list", length(seg_MIPs))
    for(i in seq_along(seg_MIPs)){
      uncollapsed[[i]] <- seg_MIPs[[i]][[1]]
      collapsed[[i]] <- seg_MIPs[[i]][[2]]
    }
    uncollapsed <- bind_rows(uncollapsed)
    collapsed <- bind_rows(collapsed)
    write_lnx_head(uncollapsed, paste0("out/", sp, "_segments_uncollapsed_", method, ".txt"))
    write_lnx_head(collapsed, paste0("out/", sp, "_segments_collapsed_", method, ".txt"))
    #consider adding the third, NULL object
    u_c_r <- list("uncollapsed" = uncollapsed, "collapsed" = collapsed, "raw_MIP_seg" = NULL)
    return(u_c_r)
  } else {
    seg <- seg %>% mutate(species = sp) %>% relocate(species) %>% mutate(len = seg_end_MIP - seg_start_MIP)
    u_c_r <- list("uncollapsed" = NULL, "collapsed" = NULL, "raw_MIP_seg" = seg)
    return(u_c_r)
  }
}

read_microhap_rds <- function(rds){
  #takes dataframe produced by microhaplot, adds some extra info and returns modified dataframe
  #the extra info is: 
  #- geneMIP split into two
  #- total ind coverage (all mips) 
  #- ind MIP coverage
  #- haplotype PAF
  d <- readRDS(rds)
  d <- d %>% separate(locus, c("gene", "MIP"), sep = "_MIP_", remove = FALSE, convert = TRUE)
  d <- d %>% group_by(id) %>% mutate(id_cov = sum(depth))
  d <- d %>% group_by(id, locus) %>% mutate(id_loc_cov = sum(depth),
                                            PAF = depth/id_loc_cov) %>%
    select(group, gene, MIP, id, haplo, depth, id_cov, id_loc_cov, PAF, everything()) %>%
    arrange(gene, MIP, id, desc(PAF))
  return(d)
}

add_haplo <- function(d, bed, refseq, taxon){
  #takes dataframe produced by read_microhap_rds (d)
  #and adds full sequences of MIP haplotypes
  #does this only for polymorphic MIPs, so add_inv_hapl (below) is also needed
  subst <- function(haplo, seg = MIP_target){
    hapseq <- unlist(strsplit(haplo, split=""))
    for(i in seq_along(hapseq)){
      seg[SNPpos[i]] <- hapseq[i]
    }
    seg <- paste(seg, collapse = '')
    return(seg)
  }
  #function has to be vectorized to work with mutate
  subst_v <- Vectorize(subst)
  MIPs <- d %>% pull(MIP) %>% unique()
  added <- vector("list", length(MIPs))
  counter <-  0
  for(MIPid in MIPs){
    counter <- counter + 1
    MIPcoord <- bed %>% filter(MIP_id == MIPid)
    g <- MIPcoord[[1]]
    s <- as.integer(MIPcoord[[2]] + 1)
    e <- as.integer(MIPcoord[[3]])
    MIP_target <- toupper(as.character(refseq[g])[[1]][s:e])
    SNPpos <- read.delim(paste0("vcf/", taxon, "_vcf/", taxon, "_", MIPid, "_raw_gatk.vcf"), header = FALSE, comment.char = "#")$V2
    SNPpos <- SNPpos - (s - 1)
    MIP_df <- d %>% filter(MIP == MIPid) %>% ungroup()
    MIP_df <- MIP_df %>% mutate(full_haplo = subst_v(haplo))
    added[[counter]] <- MIP_df
  }
  res <- bind_rows(added)
  res <- res %>% rename(species = group) %>% 
    select(species, gene, MIP, id, haplo, depth, id_cov, id_loc_cov, PAF, rank, full_haplo)
  return(res)
}

add_inv_haplo <- function(c, bed, category = c("coll", "raw")){
  #adds MIP reference sequence - useful for MIPs without SNPs
  #join haplotype data with collapsed segment data
  #input dataframe contains joined segment (collapsed or uncollapsed)
  #and variable haplotype data
  #output is dataframe 
  pol <- c %>% filter(!is.na(haplo))
  d <- c %>% filter(is.na(haplo))
  MIPs <- d %>% pull(MIP) %>% unique()
  added <- vector("list", length(MIPs))
  counter <-  0
  for(MIPid in MIPs){
    counter <- counter + 1
    MIPcoord <- bed %>% filter(MIP_id == MIPid)
    g <- MIPcoord[[1]]
    s <- as.integer(MIPcoord[[2]] + 1)
    e <- as.integer(MIPcoord[[3]])
    MIP_target <- toupper(as.character(refseq[g])[[1]][s:e])
    MIP_target <- paste(MIP_target, collapse = '')
    MIP_df <- d %>% filter(MIP == MIPid) %>% ungroup() %>% mutate(full_haplo = MIP_target)
    added[[counter]] <- MIP_df
  }
  nonpol <- bind_rows(added)
  if(category == "coll"){
    nonpol <- nonpol %>% 
      select(species, gene, MIP, id, haplo, depth, id_cov, id_loc_cov, PAF, rank, full_haplo, 
             coll_start_ref, coll_end_ref, coll_start_MIP, coll_end_MIP, coll_seg_id, coll_nSNP, abov_thr, coll_length)
    pol  <- pol %>% 
      select(species, gene, MIP, id, haplo, depth, id_cov, id_loc_cov, PAF, rank, full_haplo,
             coll_start_ref, coll_end_ref, coll_start_MIP, coll_end_MIP, coll_seg_id, coll_nSNP, abov_thr, coll_length)
    res <- bind_rows(pol, nonpol)
    return(res)
  } else if (category == "raw"){
    nonpol <- nonpol %>% 
      select(species, gene, MIP, id, haplo, depth, id_cov, id_loc_cov, PAF, rank, full_haplo, 
             seg_start_ref, seg_end_ref, seg_start_MIP, seg_end_MIP, seg_id, nSNP, len)
    pol  <- pol %>% 
      select(species, gene, MIP, id, haplo, depth, id_cov, id_loc_cov, PAF, rank, full_haplo,
             seg_start_ref, seg_end_ref, seg_start_MIP, seg_end_MIP, seg_id, nSNP, len)
    res <- bind_rows(pol, nonpol)
    return(res)
  }
}

#calculates the distribution of the number of haplotypes per indivdual for each gene
#used to estimate the maximum number of genes and a measure of support 
#(on how many individuals the maximum estimate is based)
nhap_ind_distr <- function(t, suffix = "_seg_microhap_raw_MIP_seg_min20cov", gene_ids = "gene_ids.txt") {
  #get data
  d <- readRDS(paste0("rds/", t, suffix, ".rds"))
  genes <- read_tsv(gene_ids)
  
  #distribution of the number of alleles per individual based on MIP haplotypes
  fMIP <- d %>% select(species, gene, MIP, id, haplo, id_loc_cov, PAF) 
  fMIP <- fMIP %>% filter(!grepl("N|X", haplo), id_loc_cov >=20, PAF >= 0.1) %>% distinct()
  fMIP <- fMIP %>% group_by(species, gene, MIP, id) %>% summarise(n_hap = n())
  fMIP <- fMIP %>% ungroup() %>% group_by(species, gene, n_hap) %>% 
    summarise(n_cases = n()) %>% mutate(type = "MIP")
  
  #distribution of the number of alleles per individual based o segment haplotypes
  fseg <- d %>% select(species, gene, id, id_loc_cov, PAF, seg_id, seg_hap) 
  fseg <- fseg %>% filter(!grepl("N|X", seg_hap), id_loc_cov >=20, PAF >= 0.1) %>% 
    select(-c(id_loc_cov, PAF)) %>% 
    group_by(species, gene, id, seg_id, seg_hap) %>% distinct()
  fseg <- fseg %>% group_by(species, gene, seg_id, id) %>% summarise(n_hap = n())
  fseg <- fseg %>% ungroup() %>% group_by(species, gene, n_hap) %>% 
    summarise(n_cases = n()) %>% mutate(type = "segment")
  
  fhap <- rbind(fMIP, fseg) %>% arrange(species, gene, n_hap, type) %>% left_join(genes, by = "gene") %>% 
    select(species, gene_sym, type, n_hap, n_cases)
  return(fhap)
}
  
#samples 15 individuals from species for MHC and BRD2
#if all in MIP15 were genotyped in MHC and BRD2, takes these
#if not, first tries to add inds that were genotyped in both MHC and BRD2
#if not possible, adds for each individuals randomly topping to 15
#input is list of species with named vectors 
#"MIP_ind"   "MIP_ids"   "MIP_ind15" "MIP_ids15" "2"         "3"         "brd2"      
#output is the list with the intial and with the added elements
get_15_mhc_brd <- function(tax){
  #both exons genotyped
  ex2_3 <- intersect(tax[["2"]], tax[["3"]])
  #both exons and brd2 genotyped
  ex2_3_brd2 <- intersect(ex2_3, tax[["brd2"]])
  MIP15 <- tax[["MIP_ind15"]]
  brd2 <- tax[["brd2"]]
  #MIP15, MHC and BRD2 genotyped
  mhc_brd15 <- intersect(MIP15, ex2_3_brd2)
  l_15 <- length(mhc_brd15)
  #if not enough add extra inds
  if (l_15 < 15) {
    need <- 15 - l_15
    #assumes that there will always be enough
    extr_mhc <- sample(setdiff(ex2_3, mhc_brd15), need)
    extr_brd <- sample(setdiff(brd2, mhc_brd15), need)
    tax[["mhc15"]] <- union(mhc_brd15, extr_mhc)
    tax[["brd15"]] <- union(mhc_brd15, extr_brd)
  } else {
    tax[["mhc15"]] <- mhc_brd15
    tax[["brd15"]] <- mhc_brd15
  }
  return(tax)
}


# BODY # 

#IMPORTANT
#all coodinates in tables are 0-based, half-open (bed-tools style)
#SNPs are 1-based closed
#checked manually whether all these fit and they do

# Load external data  ####

taxa <- c("Amb_tex", "Amb_tig", "And_dav", "Bat_att", "Bat_nig", "Des_fus", "Eur_bis", "Hyd_ita", "Hyd_stri",
          "Hyn_lee", "Hyn_ret", "Hyn_tok", "Ich_alp", "Kar_kor", "Lis_bos", "Lis_hel", "Lis_ita", "Omm_nes", "Omm_oph",
          "Plet_cin", "Pleu_wal", "Prot_ang", "Sal_sal", "Tri_cri", "Tri_dob", "Tri_iva", "Tri_kar", "Tri_mac", "Tri_mar", "Tri_pyg")


#Identify MIPs with median coverage < 20 within species ####
#and outputs modified version as MIPnumber_min20cov.txt to be used by bash script 
#normally doesn't have to be re-run
lows <- NULL
for (t in taxa) {
  b <- read_microhap_rds(paste0("rds/", t, "_final.rds"))
  d <- b %>% ungroup() %>% select(group, MIP, id, id_loc_cov) %>% distinct()
  e <- d %>% group_by(group, MIP) %>% summarise(mean = mean(id_loc_cov),
                                                median = median(id_loc_cov))
  hig <- e %>% filter(median >=20)
  low <- e %>% filter(median < 20)
  lows[[t]] <- low
}

lowsdf <- bind_rows(lows) %>% mutate(sp_mip = paste(group, MIP, sep = "_"))
g <- lowsdf %>% group_by(group) %>% summarise(n = n())

#df with MIPs to exclude
MIPs_to_exclude <- lowsdf %>% select(group, MIP) %>% rename("species" = "group")
saveRDS(MIPs_to_exclude, "MIPs_to_exclude_min20cov.rds")

MIPnumber <- read_tsv("MIPnumber.txt", col_names = c("gene", "start", "stop", "MIP", "tax")) %>%
  mutate(sp_mip = paste(tax, MIP, sep = "_"))

to_excl <- lowsdf %>% pull(sp_mip)

MIPnumber_min20 <- MIPnumber %>% filter(! sp_mip %in% to_excl)
write_tsv(select(MIPnumber_min20, -sp_mip), "MIPnumber_min20cov.txt", col_names = FALSE)


# #Drops less covered duplicate and saves the resulting list of ids ####
# #Takes 15 ind with most MIPs at min20x ####
# #produces the list of typed ids and inds - inds are integers
# #(to make stuff compatible betwen MIP, MHC & BRD2)
# #and ids are characters to incorporate "d" when needed
# 
# typed_MIP <- NULL
# for (t in taxa){
#    rds <- read_microhap_rds(paste0("rds/", t, "_final.rds"))
#    b <- rds %>% ungroup() %>% select(MIP, id, id_cov, id_loc_cov) %>% distinct() %>%
#      mutate(id_no_d = str_remove(id, "d"))
#    c <- b %>% group_by(id, id_no_d, id_cov) %>% summarise(N_min20x = sum(id_loc_cov >=20)) %>% ungroup()
#    d <- c %>% group_by(id_no_d) %>% arrange(desc(N_min20x), .by_group = TRUE) %>% slice_head(n = 1)
#    d15 <- d %>% ungroup() %>% arrange(desc(N_min20x)) %>% slice_head(n = 15)
#    #add ids of 15 best covered
#    #ind - individual with id in database
#    #ids - may or may not include "d"
#    #MIP_ind: ind after dropping less covered duplicate
#    #MIP_ids: ids after dropping less covered duplicate
#    #MIP_ind15: 15 best covered individuals
#    #MIP_ids15: 15 best covered ids
#    typed_MIP[[t]] <- list("MIP_ind" = sort(as.integer(d$id_no_d)),
#                           "MIP_ids" = d$id,
#                           "MIP_ind15" = sort(as.integer(d15$id_no_d)),
#                           "MIP_ids15" = d15$id)
#  }
# saveRDS(typed_MIP, "Ids_typed_MIPs.rds")
# typed_ampl <- readRDS("Ids_typed_amplicons.rds")
# 
# #list elements "MIP_ids" contain individual ids as character
# #after removing less covered duplicates
# #samples 15 ind in MHC and BRD2 according to rules in
# #get_15_mhc_brd
# 
# typed <- Map(c, typed_MIP, typed_ampl)
# typed15 <- lapply(typed, get_15_mhc_brd)
# saveRDS(typed15, "Ids_typed_MIPs_amplicons.rds")

#Gets segments ####

for(t in taxa) {
  #get reference sequences
  refseq <- read.FASTA(paste0("ref/", t, "_APG_controls_references.fas"))
  
  #Bed with MIP coordinates
  #0-based, half-open
  MIP_bed <- read.table(paste0("beds/", t, "_MIP_min20cov.bed"), sep = "\t", 
                        col.names = c("ref", "MIP_start", "MIP_end", "MIP_id"))
  
  #get datarame produced by microhaplot and update it
  #by adding additional info about individual coverage, MIP coverage and PAF
  #will contain only polymorphic MIPs
  rds <- read_microhap_rds(paste0("rds/", t, "_final.rds"))
  
  #IMPORTANT! this code filters out MIPs with median cov < 20, 
  #it's used to elongate segments
  to_excl <- readRDS("MIPs_to_exclude_min20cov.rds") %>% filter(species == t) %>% pull(MIP)
  print(to_excl)
  rds <- rds %>% filter(!MIP %in% to_excl)
  
  #add full sequences of MIP haplotypes
  rds_full_haplo <- add_haplo(rds, MIP_bed, refseq, t)
  
  
  #for each segment assigns representative MIP [this version not used anymore]
  #collapses adjacent segments represented by the same MIP
  #extracts from the results uncollapsed collapsed and raw_MIP_seg segments
  #if repr_MIP = F, the first two will be NULL, otherwise the third will be NULL
  repr <- FALSE
  #method for collapsing MIPs used by get_MIPs_for_segments within seg_MIP
  m <- "black"
  z <- seg_MIP(t, repr_MIP = repr, method = m)
  uncollapsed <- z[["uncollapsed"]]
  collapsed <- z[["collapsed"]]
  #only this is used now
  raw_MIP_seg <- z[["raw_MIP_seg"]]
  
  if (repr == TRUE){
    catg <- "coll"  
    #join haplotype data with collapsed segment data
    c <- full_join(rds_full_haplo, collapsed, by = c("MIP" = "MIP_id", "species", "gene"))
  } else {
    catg <- "raw"
    #join haplotype data with raw segment data
    c <- full_join(rds_full_haplo, raw_MIP_seg, by = c("MIP" = "MIP_id", "species", "gene"))
  }
  #adds info on sequences of nonpolymorphic MIPs
  c <- add_inv_haplo(c, MIP_bed, category = catg)
  #gets coverage info to add for nonpolymorphic MIPs
  MIP_ind_cov <- read.table(paste0("cov/", t, "_MIPcoverage_Ind.txt"), header = T, sep = "\t", encoding="UTF-8")
  MIP_ind_cov <- MIP_ind_cov %>% rowwise() %>% 
    mutate(id = str_split(Ind, "-")[[1]][[1]]) %>%
    rename(id_loc_cov = Coverage,
           species = Species) %>% select(species, id, MIP, id_loc_cov)
  
  #gets nonpolymorphic MIPs from c
  nonpol <- c %>% filter(is.na(haplo))
  
  #gest polymorphic MIPs from c
  pol <- c %>% filter(!is.na(haplo)) %>% mutate(polymorphic = TRUE)
  
  #individual_coverage
  ind_cov <- c %>% select(id, id_cov) %>% distinct() %>% filter(!is.na(id))
  
  nonpol <- left_join(nonpol, MIP_ind_cov, by = c("species", "MIP")) %>% select(-c(id.x, id_loc_cov.x)) %>%
    rename(id = id.y, id_loc_cov = id_loc_cov.y) %>% 
    relocate(id, .after = MIP) %>% relocate(id_loc_cov, .after = id_cov) %>%
    left_join(., ind_cov, by = "id") %>% relocate(id_cov.y, .after = id_cov.x) %>% 
    select(-id_cov.x) %>% rename(id_cov = id_cov.y)  %>% mutate(polymorphic = FALSE)
  
  #gets list of ids to keep in the full dataset (drops less covered dulicates)
  #and list of ids to keep in 15 ind dataset
  
  typed <- readRDS("Ids_typed_MIPs_amplicons.rds")
  id_keep <- typed[[t]][["MIP_ids"]]
  id_keep15 <- typed[[t]][["MIP_ids15"]]
  
  #gets together pol and nonpol and adds the column with haplotype sequence for the segment
  if (catg == "coll"){
    pol_nonpol <- bind_rows(pol, nonpol) %>% 
      mutate(seg_hap = str_sub(full_haplo, start=coll_start_MIP+1, end=coll_end_MIP)) %>% 
      filter(id %in% id_keep)
    saveRDS(pol_nonpol, paste0("rds/", t, "_seg_microhap_", m, ".rds"))
    best15 <- pol_nonpol %>% filter(id %in% id_keep15)
    saveRDS(best15, paste0("rds/", t, "_seg_microhap_", m, "_15_best_covered.rds"))
  } else if (catg == "raw"){
    pol_nonpol <- bind_rows(pol, nonpol) %>% 
      mutate(seg_hap = str_sub(full_haplo, start=seg_start_MIP+1, end=seg_end_MIP)) %>% 
      filter(id %in% id_keep)
    saveRDS(pol_nonpol, paste0("rds/", t, "_seg_microhap_raw_MIP_seg_min20cov.rds"))
    best15 <- pol_nonpol %>% filter(id %in% id_keep15)
    saveRDS(best15, paste0("rds/", t, "_seg_microhap_raw_MIP_seg_min20cov_15_best_covered.rds"))
  }
  
}

# # Distribution of the number of haplotypes per segment/MIP per individuals ####
# dist_nhap <- lapply(taxa,nhap_ind_distr) 
# dist_nhap <- bind_rows(dist_nhap)
# saveRDS(dist_nhap, "Distr_nhap_per_segment_per_individual.rds")
# 
# #Maximum number of alleles per individual per gene ####
# #various ways of counting the maxima
# dist_nhap <- readRDS("Distr_nhap_per_segment_per_individual.rds") %>% ungroup()
# names(dist_nhap)
# max_nhap <- dist_nhap %>% select(-gene) %>% group_by(species, gene_sym, type) %>% 
#   summarise(max_hap = max(n_hap),
#             max_hap_min2ind = max(n_hap[n_cases > 1]),
#             max_hap_min3ind = max(n_hap[n_cases > 2])) %>% rename(sp_abr1 = species)
# 
# mhc_stats <- read_tsv("Basic_statistics.txt") %>% as.data.frame() %>% filter(exon == "3")
# 
# gene_n <- max_nhap %>% left_join(mhc_stats, by = "sp_abr1") %>% 
#   filter(gene_sym %in% c("PSMB8", "PSMB9", "TAP1", "TAP2", "TAPBP"))
# 
# #plot max number of alleles per genes vs max number of MHC alleles per species
# ggplot(gene_n, aes(x = max_N_funct_alleles_per_ind, y = max_hap_min3ind, colour = gene_sym, group = gene_sym)) +
#   geom_point() + facet_wrap(~type,  ncol=2) + geom_smooth(method = 'lm', se = FALSE) +
#   xlab("maximum number of MHC-I alleles per individual") +
#   ylab("maximum number of alleles per individual")

